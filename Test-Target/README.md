# Single-Node e-Voting Server
In the project, you will implement the voting logic of the e-Voting server. We assume that there is just one single voting server. The voting clients will connect to the voting server to participate in the elections.

## Usage
- Run server `python voting_server.py`
- Run client `python voting_client.py`

## Local Server API
### VerifyAuthToken (**auth_token**) returns (**True / False**)
- Server's API can use it to verify the given **auth_token**'s validity.
- There's a **auth_tokens** dictionary to store information of server stored auth tokens.
- If the given **auth_token** is not found in **auth_tokens**, it'll return **False**
- If the  given **auth_token** is expired, it'll return **False**
- If the  given **auth_token** is valid, it'll update the expired time and return **True**

### RegisterVoter(`Voter`) returns (`Status`)
- We can register a new Voter by calling the RegisterVoter API.
- The server side can use voter.txt to register voters.
- voter.txt will contain the voter's name, group, and seed.
- The seed will use to generate a public key.
- return code:
    - Status.code=0 : Successful registration
    - Status.code=1 : Voter with the same name already exists
    - Status.code=2 : Undefined error

### UnregisterVoter(`VoterName`) returns (`Status`)
- This API is used for unregistering a voter with the name VoterName.
- The server side can unregister a certain voter's name.
- return code:
    - Status.code=0 : Successful unregistration
    - Status.code=1 : No voter with the name exists on the server
    - Status.code=2 : Undefined error

## RPC APIs
### PreAuth (`VoterName`) returns (`Challenge`)
- When client makes PreAuth request, server will reply a challenge token **b'Challenge'**.
- After client receives the challenge token, client will use its ed25519 private key to sign the challenge token. (ed25519 private key is a constant currently)
- Then client will **automatically** call RPC API **Auth**, using signed signature above as request message.
### Auth (`AuthRequest`) returns (`AuthToken`)
- When server receives Auth request, it'll verify the signature with challenge token **b'Challenge'** and client's ed25519 public key. (ed25519 public key is a constant currently)
- If signature's validity is checked, server will reply a auth token, generated by **os.urandom(64)**.
- At meanwhile, server will stored the voter name, auth token, and its expired time into **auth_tokens** dictionary
###  CreateElection (`Election`) returns (`Status`)
- Authenticated voter can create an election. 
- `name`, `groups`, `chioces`, `end date` are required and **MUST** use the defined format.
    - groups: **MUST** seperate groups by `,`
    - choices: **MUST** seperate choices by `,`
    - end date: **MUST** follow the format of timestamp. e.g., 2023-01-01T00:00:00
- return code:
    - 0: election is created successfully
    - 1: invalid authentication token
    - 2: missing groups or choices
    - 3: unknown error 
###  CastVote (`Vote`) returns (`Status`)
- Authenticated voter can cast the vote to the choice wanted
- `election name` and `choice name` are required
- return code:
    - 0: cast the vote successfully
    - 1: invalid authentication token
    - 2: invalid election name
    - 3: the voter's group is not allowed (ongoing)
    - 4: previous vote has been cast
###  GetResult(`ElectionName`) returns (`ElectionResult`)
- query the result of the election
- `election name` is required
- return code:
    - 0: query successful and return the list of choices and the ballot counts
    - 1: non-existent election
    - 2: the election is still ongoing